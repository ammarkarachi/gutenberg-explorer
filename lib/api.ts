import { BookMetadata } from '@/types';
import axios from 'axios';


let bookRecords: BookRecord[] | null = null;

/**
 * Fetches TSV data from a given URL and caches it
 */
export async function fetchAndCacheTsv(): Promise<string | null> {
  try {
    const tsvUrl = 'https://raw.githubusercontent.com/gitenberg-dev/giten_site/refs/heads/master/assets/GITenberg_repos_list_2.tsv';
    const response = await axios.get(tsvUrl);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch TSV data:', error);
    throw new Error('Failed to fetch TSV data');
  }
}
type BookRecord = {
  gitb_id: string;
  gitb_name: string;
  title: string;
  language: string;
  text_files: string[];
};

/**
 * Parses TSV data and transforms it into an array of BookRecord objects
 */
export async function getBookRecords(): Promise<BookRecord[]> {
  const records: BookRecord[] = [];
  if (bookRecords) {
    return bookRecords;
  }
  const tsv = await fetchAndCacheTsv();
  console.log(tsv)
  if (!tsv) {
    throw new Error('Failed to fetch TSV data');
  }
  const lines = tsv.split('\n');
  const headers = lines[0].split('\t');

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].split('\t');
    const record: BookRecord = {
      gitb_id: line[headers.indexOf('gitb_id')],
      gitb_name: line[headers.indexOf('gitb_name')],
      title: line[headers.indexOf('title')],
      language: line[headers.indexOf('language')],
      text_files: parseTextFiles(line[headers.indexOf('text_files')]),
    };
    records.push(record);
  }

  return records;
}
function parseTextFiles(textFiles: string): string[] {
  if (!textFiles) {
    return [];
  }
  textFiles = textFiles.replace("[", "").replace("]", "");
  return textFiles.split(',').map(file => file.trim());
}


/**
 * Fetches book content from Project Gutenberg
 */
export async function fetchBookContent(bookId : string): Promise<string> {
  try {
    const bookRecords = await getBookRecords();
    const bookRecord = bookRecords.find(record => record.gitb_id === bookId);
    if (!bookRecord) {
      throw new Error(`Book ID ${bookId} not found`);
    }
    
    const url = `https://raw.githubusercontent.com/GITenberg/${bookRecord.gitb_name}/master/${bookRecord.text_files[0]}`;
    const response = await axios.get<string>(url);
    return response.data;

  } catch (error) {
    console.error('Failed to fetch book content:', error);
      throw new Error(`Failed to fetch book content for ID ${bookId}`);
  }
}

/**
 * Fetches book metadata from Project Gutenberg
 */
export async function fetchBookMetadata(bookId: string) {
  try {
    const metadataUrl = `https://gutendex.com/books/${bookId}`;
    const response = await axios.get<BookMetadata>(metadataUrl);
    const data = response.data
    console.log(data)
    
    return {
      title: data.title,
      author: data.authors.map(author => author.name).join(', '),
      language: data.languages.join(', '),
      subjects: data.subjects || [],
      summary : data.summaries[0],
      coverImage: data.formats['image/jpeg'],
      content: await fetchBookContent(bookId),
    };
  } catch (error) {
    throw new Error(`Failed to fetch book metadata for ID ${error}`);
  }
}

/**
 * Simple helper function to extract text with regex
 */
function extractWithRegex(text: string, regex: RegExp): string | null {
  const match = text.match(regex);
  return match ? match[1].trim() : null;
}

/**
 * Analyzes book text using an LLM API
 * This is a placeholder - in a real app, you'd integrate with OpenAI, Anthropic, etc.
 */
export async function analyzeBookText(
  bookId: string, 
  text: string, 
  analysisType: 'characters' | 'summary' | 'sentiment' | 'themes'
) {
  // In a real app, you'd call your LLM API here
  // For example with OpenAI:
  /*
  const response = await axios.post('https://api.openai.com/v1/chat/completions', {
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: "You are a literary analysis assistant."
      },
      {
        role: "user",
        content: `Analyze the following book text and provide ${analysisType} analysis: ${text.substring(0, 8000)}...`
      }
    ]
  }, {
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json'
    }
  });
  
  return response.data.choices[0].message.content;
  */
  
  // For now, return mock data based on analysis type
  return {
    characters: [
      { name: 'Character 1', description: 'Main protagonist', importance: 'Primary' },
      { name: 'Character 2', description: 'Antagonist', importance: 'Primary' },
      { name: 'Character 3', description: 'Supporting character', importance: 'Secondary' },
    ],
    summary: 'This is a mock plot summary that would be generated by the LLM.',
    sentiment: {
      overall: 'Positive',
      beginning: 'Neutral',
      middle: 'Tense',
      end: 'Positive',
      analysis: 'The narrative begins with neutral observations, develops tension in the middle, and resolves positively.'
    },
    themes: [
      { theme: 'Theme 1', description: 'Description of theme 1' },
      { theme: 'Theme 2', description: 'Description of theme 2' },
      { theme: 'Theme 3', description: 'Description of theme 3' },
    ]
  }[analysisType];
}